# Практика

В рамках курса backend на java предлагается написать приложение, состоящее из нескольких сервисов. Таким образом, будет
получен опыт написания spring-boot приложений, работы с БД стандартными средствами spring-boot и взаимодействия между
приложениями - как по HTTP, так и через очереди сообщений.

Курс рассчитан на написание только backend, разработка frontend части не требуется

## Краткое описание - приложение Мессенджер

Это система, в которой можно зарегистрироваться, заполнить профиль и начать общение. Можно заводить друзей, создавать
чаты и общаться. Система при этом должна быть удобной, позволять находить нужную информацию, уведомлять о различных
событиях.

## Задание 1 (до 17 апреля)

Реализовать в соответствии с ниже описанными требованиями следующие сервисы:
- Шлюз API (Gateway API)
- Сервис аутентификации и профилей (User)
- Сервис друзей (Friends)

Написание автотестов и сваггера для данного задания исключаются


## Задание 2 (до 22 мая)

Реализовать все модули с полным набором требований
- Шлюз API (Gateway API)
- Сервис аутентификации и профилей (User)
- Сервис чатов (Chat)
- Сервис друзей (Friends)
- Сервис уведомлений (Notif)
- Сервис файлового хранилища (File Storage)


# Требования информационной системе

## Архитектура

Система должна быть выполнена в микросервисной архитектуре, во всяком случае стремиться к ней. У каждого сервиса должна
быть своя зона ответственности, свой кусочек функционала, максимально изолированный от остальных сервисов.

Репозиторий должен состоять из одного многомодульного maven-проекта.

Предлагается следующий набор сервисов:

- Шлюз API (Gateway API)
- Сервис аутентификации и профилей (User)
- Сервис чатов (Chat)
- Сервис друзей (Friends)
- Сервис уведомлений (Notif)
- Сервис файлового хранилища (File Storage)

Схема взаимодействия сервисов
![Services-schema](img/services-schema.jpg)

Синим обозначены базы данных для сервисов (PG), жёлтым - файловое хранилище S3.  
Схема лишь поверхностно отражает связи сервисов, она может не содержать всех маршрутов данных.

## Общие требования к сервисам

- Работа с БД
    - Любой сервис, в котором подразумевается хранение информации (есть сущности в требованиях)
      должен иметь собственную БД. Каждый сервис сам отвечает за миграцию своей БД через flyway

- Контроллеры
    - Аутентификация пользователей должна осуществляться по JWT. Аутентификация интеграционных
      межсервисных запросов - по api key (просто ключу).
    - Все HTTP-методы должны оперировать только DTO, никаких сущностей БД на "клиент" улетать не должно
    - Все методы должны проходить валидацию - во многих методах есть обязательные к заполнению поля
    - Необходима обработка ошибок, например при поиске пользователя по несуществующему идентификатору - не должна валится
      500 ошибка, она должна быть обработана, в ответе выдан 4xx статус с понятным сообщением о проблеме.  
      При возникновении ошибок запроса или сервера, нельзя возвращать стектрейс, как это может происходить по дефолту

- Все функции сервисов должны быть покрыты автотестами

- Все пользовательские и межсервисные запросы должны логироваться

- Классы и их методы должны быть задокументированы (javadoc)


# Шлюз API (Gateway API)

Это сервис, который должен быть входной точкой для всех API. Через него должен осуществляться доступ по HTTP ко всем
сервисам со стороны пользователя


# Сервис аутентификации и профилей (User)

В этом сервисе должен производиться учёт пользователей, их профилей и аутентификация.

Корневой путь: `/users`

Там, где это необходимо для актуализации данных, должно производиться интеграционное взаимодействие
по HTTP или RabbitMQ

#### Сущности

- Пользователь
    - Идентификатор (задаётся автоматически)
    - Дата регистрация (задаётся автоматически)
    - Логин (уникальное)
    - Почта (уникальное)
    - Пароль (в зашифрованном виду, PasswordEncoder)
    - ФИО
    - Дата рождения
    - Телефон
    - Город
    - Аватарка (UUID, который будет id файла в S3)

Делается допущение, что единственная сущность сервиса - является одновременно реестром пользователей и реестром профилей

**Функции сервиса**

- POST метод: Регистрация  
  Функция, по которой самостоятельно может зарегистрироваться в системе новый пользователь
    - Тело запроса
        - Логин (уникальное)
        - Почта (уникальное)
        - ФИО
        - Опционально - все остальные поля сущности Пользователь
    - Ответ: данные профиля  
      При этом должен присваиваться именно хидер аутентификации с JWT со стороны бэка

- POST метод: Вход в систему  
  Метод в хода в систему по логину и паролю. При успешном исходе, пользователю должно отправляться уведомление
  о воде в систему с датой и временем входа, с указанием IP откуда осуществлялся вход
    - Тело запроса
        - Логин
        - Пароль
    - Ответ: данные профиля  
      При этом должен присваиваться именно хидер аутентификации с JWT со стороны бэка  
      При неверном вводе пароля/

- POST метод: Список пользователей
    - Тело запроса
        - Информация о пагинации (номер и размер страницы)
        - Список фильтров по всем полям профиля. Пользователь при этом должен иметь возможность указать произвольный
          набор из доступных фильтров. Фильтры по текстовым полям должны быть регистро-независимыми и искать
          по части строки (в переводе на sql: like)
        - Список полей сортировки
    - Ответ
        - Информацию о текущей странице и сортировке
        - Массив данных о профилях пользователей на текущей странице

- GET метод: Просмотр профиля пользователя  
  Просмотр профилей пользователей, которые добавили текущего в чёрный список - запрещен в данном
  методе (несмотря на то, что есть список пользователей)
    - Принимает на вход: логин пользователя
    - Тело ответа: данные профиля пользователя

- GET метод: Просмотр информации о себе  
  По сути, такой же метод, как Просмотр профиля пользователя, только на вход не
  принимает параметры, а id пользователя должен извлекать из текущего токена. Тело ответа: данные профиля

- PUT метод: Изменение профиля  
  Метод изменение информации о профиле текущего пользователя
    - Тело запроса
        - ФИО
        - Дата рождения
        - Телефон
        - Город
        - Аватарка (UUID, который будет id файла в S3)
    - Тело ответа: данные профиля

> Изменение профиля должно провоцировать отправку события через RabbitMQ, которое должны слушать все
> сервисы, нуждающиеся в обновлении данных о пользователе (ФИО). Соответственно, другие сервисы, хранящие ФИО
> и, возможно, ещё какие-то изменяемые данные пользователя, должны реализовать слушателя событий изменения этих
> данных, в которых будет производиться апдейт

# Сервис чатов (Chat)

Это сервис, в котором будут вестись диалоги и создаваться чаты. Сервис должен позволять отправлять сообщения в личке и
загружать список последних сообщений. Так же сервис должен предоставлять гибкий поиск сообщений по нескольким фильтрам:
дате, названию чата. Отправку пользователем сообщений или их просмотр тем или иным способом, система должна позволять
только в тех диалогах или чатах, в которых текущий пользователь состоит

Под диалогом подразумевается личная переписка двух пользователей, куда нельзя добавить никого. Такая переписка
может начаться сразу с отправки сообщения, диалог должен создаться автоматически, если его нет.

Под чатом подразумевается переписка нескольких пользователей, куда можно добавлять несколько людей. Любой пользователь
может создать свой чат, добавить туда своих друзей. Добавленные пользователи тоже могут добавить своих друзей.

У сообщения (диалоги и чаты) может быть произвольное кол-во вложений по желанию пользоателя.
Размер файла до 10МБ, кол-во файлов максимум - 10 (настраиваемые величины)

- Находясь в чёрном списке у пользователя, нельзя
    - Отправить ему сообщение в личке
    - Добавить его в тот или иной чат
- В личке написать можно только другу

**Корневой url:** `/chat`

Там, где это необходимо для актуализации данных, должно производиться интеграционное взаимодействие
по HTTP или RabbitMQ

#### Сущности

В данном сервисе разрешается иной подход к схеме данных БД, отличающийся от предложенного ниже, если
при этом не нарушаются требования к функциям сервиса. Предложенная ниже схема неполная, в любом случае
студент должен её доработать

- Чат (ниже по тексту ещё название - переписка)
    - Идентификатор (задаётся автоматически)
    - Тип чата (Диалог/Чат)
    - Наименование (только для чатов)
    - Админ - идентификатор пользователя (только для чатов)
    - Дата создания (только для чатов)
    - Аватарка - идентификатор файла (только для чатов)
- Связь чат-пользователь
    - Идентификатор чата
    - Идентификатор пользователя
- Сообщение
    - Идентификатор (задаётся автоматически)
    - Ссылка на чат
    - Дата отправки
    - Текст сообщения (не длиннее 500 символов)
- Вложение
    - Идентификатор (задаётся автоматически)
    - Ссылка на сообщение
    - Идентификатор файла в хранилище
    - Наименование файла

#### Функции сервиса

- Отправка сообщения в личку  
  Как указано в требованиях, если личный чат между двумя юзерами не существует, он создаётся автоматически
    - Тело запроса
        - Идентификатор пользователя, кому отправляется сообщение
        - Текст сообщения
        - Файлы вложений. Опциональное поле, пользователь имеет право его не указывать (или пустой массив)
- Создание чата
    - Тело запроса
        - Наименование
        - Аватарка - файл изображения
        - Список пользователей-участников (кроме себя - текущий пользователь подставится автоматически)
- Изменение чата
    - Тело запроса
        - Идентификатор изменяемого чата
        - Наименование
        - Аватарка - файл изображения
        - Список пользователей-участников (кроме себя - текущий пользователь подставится автоматически)
- Отправка сообщения в чат  
  При отправке сообщения именно в диалог (не чат), должно отправляться уведомление второму участнику диалога
  о поступлении нового сообщения. Уведомление должно содержать инфо об отправителе, времени отправки и части
  сообщения (не более 100 символов из текста сообщения)
    - Тело запроса
        - Идентификатор чата
        - Текст сообщения
        - Файлы вложений. Опциональное поле, пользователь имеет право его не указывать (или пустой массив)
- Информация о переписке по id
  Метод, чтобы отображать какую-то инфу, зайдя в переписку
    - Тело ответа
        - Наименование чата (если диалог - имя собеседника)
        - Аватарка чата (если не диалог)
        - Администратор чата - идентификатор пользователя (если не диалог)
        - Дата создания чата
- Просмотр переписки
  Список сообщений в порядке убывания по дате отправки, по идентификатору чата/диалога
    - Тело ответа, массив
        - Идентификатор сообщения
        - Дата отправки сообщения
        - Текст сообщения
        - Имя отправителя
        - Аватарка отправителя - id файла аватарки
        - Массив файлов:
            - Идентификатор файла
            - Наименование файла
            - Размер файла
- Просмотр списка переписок  
  Этот метод должен выводить список переписок (чатов и диалогов) в порядке убывания даты отправки последнего
  сообщения в переписке, а так же рядом с названием переписки - само последнее в нём сообщение. Для примера,
  мессенджер телеграм или вконтакте - как по дефолту выглядят их списки чатов. Иметь в виду, что чаты и
  диалоги должны выводиться единым списком, а не раздельными.
    - тело запроса
        - Номер и размер страницы (по дефолту первая страница и 50 записей), без сортировки (она дефолтная всегда)
        - Поисковая строка по имени чата (опционально) - регистронезависимый поиск по части текста (like)
    - тело ответа, массив, с информацией о пагинации:
        - Идентификатор чата
        - Наименование чата (если не чат, а диалог - имя собеседника)
        - Текст последнего сообщения в чате
        - Признак наличия файлов-вложений в последнем сообщении (boolean, это как в мессенджерах скрепка отображается)
        - Дата отправки сообщения
        - Идентификатор пользователя-отправителя последнего сообщения в чате
- Поиск сообщений  
  Метод должен по поисковому запросу (строка) находить сообщения. Пользователю выведутся сообщения, удовлетворяющие
  условиям поиска вместе с названиями чатов/диалогов этого сообщения. Поиск должен на бэке производиться
  по тексту сообщения или имени вложения. Сортировка фиксированная - в порядке убывания по дате отправки сообщения.
  Иметь в виду, что чаты и диалоги должны выводиться единым списком, а не раздельными.
    - Тело запроса
        - Поисковая строка - регистронезависимый поиск по части текста (like)
    - Тело ответа, массив:
        - Идентификатор чата
        - Наименование чата (если диалог - имя собеседника)
        - Текст сообщения
        - Признак наличия файлов-вложений
        - Дата отправки сообщения
        - Наименования вложения сообщения

# Сервис друзей (Friends)

Данный сервис должен предоставлять пользователю возможность вести список друзей или недругов (блэклист).
Функция добавления друга должна быть взаимной: если Юзер1 добавляет Юзер2 в друзья, то Юзер2 сразу же в списке
своих друзей увидит Юзер1. Предполагается, что пользователь сначала пользуется гибким поиском людей из сервиса
User, затем любого найденного человека может добавить в друзья. Затем может открыть уже список друзей и управлять им.

Там, где это необходимо для актуализации данных, должно производиться интеграционное взаимодействие
по HTTP или RabbitMQ

#### Немного терминологии:

Целевой пользователь - это пользователь, который добавляет друзей к себе в список. Он же текущий пользователь
системы и в параметрах запросов http указываться не должен

Внешний пользователь - это пользователь, которого добавляют в тот или иной список

Корневой url: `/friends`

#### Сущности с требуемыми полями

- Друзья
    - Дата добавления друга (заполняется автоматически)
    - Дата удаления друга (заполняется автоматически)
    - Идентификатор целевого пользователя (к которому добавляются друзья)
    - Идентификатор добавляемого пользователя
    - ФИО внешнего пользователя
- Блэклист
    - Дата добавления записи (заполняется автоматически)
    - Дата удаления записи (заполняется автоматически)
    - Идентификатор целевого пользователя (Который заносит в блеклист)
    - Идентификатор добавляемого пользователя
    - ФИО внешнего пользователя

#### Требования к сервису

- Так как сущности друзей и блеклиста совпадают, допускается "полет фантазии" при разработке модуля в плане методов и
  сущностей. Как пример, можно сделать одну сущность "запись" и различать на друзей и блеклист по определенному полю. Но
  стоит иметь в виду, что в реальном проекте, такой подход может быть обречен на провал, например заказчик может
  попросить добавить 20 полей в одну сущность и убрать 3 поля из другой.

- Должна быть реализована возможность "взаимной" дружбы. То есть когда 2 пользователя добавили друг друга в друзья.

#### Требуемые методы для друзей:

- POST метод: Список друзей
  Этот метод не является полноценным списком профилей, должен выводить только друзей текущего пользователя
    - Тело запроса
        - Данные о пагинации (номер и размер страницы)
        - Фильтр по ФИО друга (опционально, wildcard фильтр)
    - Должен отдавать список друзей текущего пользователя с пагинацией
    - Дто должно содержать в себе все поля сущности друзей, кроме идентификатора целевого пользователя
    - Удаленные друзья не должны попадать в выборку

- GET метод: Просмотр друга
  Просмотр данных о выбранном друге
    - Должен принимать идентификатор друга (пользователя)
    - Должен отдавать конкретного "друга", все поля из сущности друзья

- POST метод: Добавление друга  
  При успешном исходе выполнения метода должно отправляться уведомление тому, кого текущий пользователь добавляет в друзья.
  Добавление пользователя по id в друзья текущему пользователю. Тело запроса:
    - Должен принимать в теле запроса необходимые поля для добавления друга, все поля кроме дат должны быть
      обязательными к заполнению
    - При обработке запроса, перед сохранением в БД, необходимо заполнить поле даты добавления друга
    - При обработке запроса, необходимо совершить проверку на то, что пользователь уже не добавлен в список, например по
      идентификаторам целевого и внешнего пользователя. В случае, если такая пара уже есть, но друг "удален", необходимо
      занулить дату удаления данной связки и при необходимости актуализировать данные (например, ФИО)

- PATCH метод: Синхронизация данных
    - Необходим для синхронизации данных с внешними сервисами
    - Должен принимать идентификатор друга, находить все записи, где он участвует и обновлять поле ФИО. Данная функция в
      дальнейшем так же будет использоваться при "правильной"
      синхронизации через рэббит.

- DELETE метод "Удалить друга"  
  При успешном исходе выполнения метода должно отправляться уведомление тому, кого текущий пользователь удаляет
  из друзей.
    - Принимает идентификатор: внешний пользователь
    - Удаляет из списка друзей, заполняя поле "дата удаления"

- POST метод "Поиск"
    - Принимает в теле запроса набор параметров из сущности друзья и осуществляет поиск по произвольному набору этих
      параметров. Как пример, мы решили искать по дате добавления, присылаем только эту самую дату и метод должен
      осуществить запрос в БД только по этому полю, полностью игнорируя остальные
    - Ответ должен быть с пагинацией, по аналогии с методом "Список друзей"

#### Требуемые методы для блэклиста:

- Требуются все методы по аналогии с методами добавления в друзья
- GET метод "Проверка нахождения в черном списке"
    - Метод должен принимать идентификатор внешнего пользователя и отвечать true/false в зависимости
      от нахождения в черном списке


# Сервис уведомлений

Это сервис, предоставляющий функционал по уведомлениям о различных событиях. Через RabbitMQ, сервис должен
принимать сообщения о поступающих уведомлениях для пользователей и через HTTP контроллер предоставлять
API доступа к этим уведомлениям

Не допускается приём новых уведомлений по HTTP, только через MQ

#### Сущности

- Уведомление
    - Идентификатор уведомления
    - Тип уведомления
    - Текст уведомления
    - Идентификатор пользователя
    - Статус и дата-время прочтения
    - Дата-время получения

#### Функции

> По всем API пользователя (http), пользователь может работать только со своими уведомлениями. Т.е. должен применяться
> фильтр по id или логину пользователя

- Приём уведомления через RabbitMQ
    - Тело сообщения
        - Идентификатор пользователя (uuid/login)
        - Тип уведомления  
          Это поле означает какое именно уведомление пришло. Например, уведомление о добавлении в друзья
        - Текст уведомления
- Список уведомлений с поиском  
  Всегда в порядке убывания по дате получения
    - Тело запроса
        - Номер и размер страницы (по дефолту первая страница и 10 записей), без сортировки (она дефолтная всегда)
        - Фильтры по значениям полей уведомления  
          Произвольный набор фильтров из доступных:
            - По дате получения: период - "от" и "до", необязательные поля
            - По тексту уведомления: нечеткий (по подстроке) и регистро-независимый поиск
            - По типу уведомления: множественный выбор, когда юзер в UI выбирает несколько значений из списка
    - Тело ответа, массив с информацией о пагинации:
        - Идентификатор уведомления
        - Тип уведомления
        - Текст уведомления
        - Статус прочтения
        - Дата-время получения, формат: 2023-01-01 00:00
- Кол-во непрочитанных сообщений  
  Не должны приниматься какие-либо параметры, на выходе метод должен возвращать только кол-во не прочтённых
- Пометка уведомлений прочитанными/не прочитанными
    - Тело запроса
        - Список идентификаторов уведомлений
        - Статус прочтения, в который указанные уведомления перевести
    - Тело ответа
        - Кол-во непрочитанных сообщений

#### Источники уведомлений

Чтобы не искать по всему ТЗ, в каких сервисах и в каких случаях должны отправляться уведомления,
они продублированы здесь

- Сервис пользователей (User)
    - Выполнен вход в систему: уведомление пользователю, когда выполняется успешный ввод логина и пароля
- Сервис чатов (Chat)
    - Поступило новое личное сообщение: уведомление пользователю, когда ему посылают личное сообщение (для чата это не нужно)
- Сервис друзей (Friends)
    - Новый друг (и аналогичное про блэклист): уведомление когда другой пользователь добавляет текущего в друзья
    - Удаление из друзей (и аналогичное про блэклист): уведомление когда другой пользователь удаляет текущего из друзей

# Сервис файлового хранилища

Это сервис, позволяющий загружать файлы и получать их по ссылке.

Хранение метаданных файлов в этом сервисе в его собственной БД необязательно, студент должен сам
решить, хранить их здесь или в сервисах.

Так же на ответственности студента архитектурное решение по взаимодействию с файловым сервером пользователя. Требуется
решить - будет ли файл сначала приниматься на стороне "бизнес"-сервиса или сразу будет приниматься файловым сервером.

Функции сервиса
- Загрузка файла. Когда пользователь из иного сервиса сохраняет файл в системе.
    - Тело запроса: как минимум файл. Могут быть и иные параметры
    - Тело ответа: как минимум id файла. Могут быть и иные поля
- Получение файла по id  
  Параметров кроме id нет. Тело ответа - бинарник
- Иные функции, если сочтёт нужным исполнитель
